<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEX.AI Portal</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" href="favicon.png">
    
    <!-- Solana Dependencies -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-base"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-wallets"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-phantom"></script>
</head>
<body class="with-sidebar">
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="index.html" class="logo-link">
                <svg class="logo" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    
                    <!-- Outer hexagon -->
                    <path d="M50 20 L75 32.5 L75 67.5 L50 80 L25 67.5 L25 32.5 Z" 
                          stroke="#00a2ff" 
                          stroke-width="2"
                          fill="none"
                          stroke-linecap="round"
                          filter="url(#glow)"/>
                          
                    <!-- Inner geometric pattern -->
                    <path d="M50 35 L65 42.5 L65 57.5 L50 65 L35 57.5 L35 42.5 Z" 
                          stroke="#00a2ff" 
                          stroke-width="2"
                          fill="none"
                          stroke-linecap="round"
                          filter="url(#glow)"/>
                          
                    <!-- Center connecting lines -->
                    <path d="M50 35 L50 20 M35 42.5 L25 32.5 M65 42.5 L75 32.5" 
                          stroke="#00a2ff" 
                          stroke-width="2"
                          fill="none"
                          stroke-linecap="round"
                          filter="url(#glow)"/>
                </svg>
            </a>
            <button class="sidebar-toggle">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>
                </svg>
            </button>
        </div>
        <nav class="sidebar-nav">
            <a href="#dashboard" class="nav-item active" data-tab="dashboard">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/>
                </svg>
                <span class="nav-item-text">Dashboard</span>
            </a>
            <a href="#wallet" class="nav-item" data-tab="wallet">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>
                </svg>
                <span class="nav-item-text">Wallet</span>
            </a>
            <a href="#analytics" class="nav-item" data-tab="analytics">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/>
                </svg>
                <span class="nav-item-text">Analytics</span>
            </a>
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Add this right after <main class="main-content"> -->
        <div class="top-bar">
            <div class="wallet-status" style="display: none;">
                <span id="walletAddressShort"></span>
                <button class="disconnect-btn" id="disconnectWalletBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                        <path d="M16 13v-2H7V8l-5 4 5 4v-3h9zm-1-7h6v12h-6v2h6a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-6v2z" fill="currentColor"/>
                    </svg>
                    Disconnect
                </button>
            </div>
        </div>

        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboard">
            <div class="wallet-connection" id="walletConnectionSection">
                <div class="wallet-icon">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none">
                        <path d="M19 7h-1V6a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-3-2v2H5a1 1 0 0 1 0-2h11zm4 12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8.83A3 3 0 0 0 5 9h14a1 1 0 0 1 1 1v7z" fill="currentColor"/>
                        <path d="M16 11.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z" fill="currentColor"/>
                    </svg>
                </div>
                <h1 id="walletTitle">Connect Your Wallet</h1>
                <p id="walletDescription">Connect your Solana wallet to access the full features of the portal</p>
                <div class="wallet-button-container">
                    <button class="wallet-connect-btn" id="connectWalletBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M19 7h-1V6a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-3-2v2H5a1 1 0 0 1 0-2h11zm4 12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8.83A3 3 0 0 0 5 9h14a1 1 0 0 1 1 1v7z" fill="currentColor"/>
                            <path d="M16 11.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z" fill="currentColor"/>
                        </svg>
                        <span id="walletButtonText">Connect Wallet</span>
                    </button>
                </div>
            </div>

            <!-- Token Analysis Section (shown after wallet connection) -->
            <div class="token-analysis" id="tokenAnalysisSection" style="display: none;">
                <div class="token-input-section">
                    <h2>Token Analysis</h2>
                    <p>Enter a token contract address to analyze its health and investment potential</p>
                    <div class="token-input-container">
                        <input type="text" id="tokenAddress" placeholder="Enter token contract address" class="token-input">
                        <button class="analyze-btn" id="analyzeTokenBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                                <path d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 1 0-.7.7l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0A4.5 4.5 0 1 1 14 9.5 4.5 4.5 0 0 1 9.5 14z" fill="currentColor"/>
                            </svg>
                            Analyze
                        </button>
                    </div>
                </div>

                <div class="analysis-results" id="analysisResults">
                    <!-- Results will be populated here -->
                </div>
            </div>
        </div>

        <!-- Wallet Tab -->
        <div class="tab-content" id="wallet">
            <div class="wallet-balance">
                <h2>Wallet Balance</h2>
                <p id="walletBalanceText">Please connect your wallet to view your balance</p>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div class="tab-content" id="analytics">
            <div class="analytics-data">
                <h2>Market Analytics</h2>
                <div class="token-sections">
                    <!-- Major Cryptocurrencies -->
                    <div class="token-section">
                        <h3>Major Cryptocurrencies</h3>
                        <div class="token-grid" id="majorTokens">
                            <div class="token-card loading">
                                <div class="token-header">
                                    <div class="token-icon-placeholder"></div>
                                    <h4>Loading...</h4>
                                </div>
                                <div class="token-stats">
                                    <p class="price">Price: Loading...</p>
                                    <p class="change">24h: Loading...</p>
                                    <p class="market-cap">Market Cap: Loading...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Error Message -->
    <div class="error-message">
        <svg viewBox="0 0 24 24" width="16" height="16">
            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
        </svg>
        <span>Please connect your wallet</span>
    </div>

    <!-- Add this before the closing body tag -->
    <div class="notification" id="walletNotification">
        <svg class="notification-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M21 7h-1V6a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-3-2v2H5a1 1 0 0 1 0-2h11zm4 12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8.83A3 3 0 0 0 5 9h14a1 1 0 0 1 1 1v7z"/>
            <path fill="currentColor" d="M16 11.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
        </svg>
        <div class="notification-content">
            <div class="notification-title">Wallet Required</div>
            <div class="notification-message">Please install Phantom wallet to use all features</div>
        </div>
        <button class="notification-action" onclick="window.open('https://phantom.app/', '_blank')">Install Phantom</button>
        <button class="notification-close" onclick="hideNotification()">✕</button>
    </div>

    <!-- Add this before the closing body tag -->
    <div class="notification error" id="errorNotification">
        <svg class="notification-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
        </svg>
        <div class="notification-content">
            <div class="notification-title">Connection Error</div>
            <div class="notification-message" id="errorMessage">Failed to connect wallet</div>
        </div>
        <button class="notification-close" onclick="hideErrorNotification()">✕</button>
    </div>

    <script>
        let wallet = null;
        let connection = null;
        let autoReconnectAttempted = false;

        // Token lists with IDs and static image URLs
        const majorTokens = [
            { id: 'BTC', name: 'Bitcoin', symbol: 'BTC', image: 'https://assets.coingecko.com/coins/images/1/small/bitcoin.png' },
            { id: 'ETH', name: 'Ethereum', symbol: 'ETH', image: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
            { id: 'SOL', name: 'Solana', symbol: 'SOL', image: 'https://assets.coingecko.com/coins/images/4128/small/solana.png' },
            { id: 'LTC', name: 'Litecoin', symbol: 'LTC', image: 'https://assets.coingecko.com/coins/images/2/small/litecoin.png' },
            { id: 'ADA', name: 'Cardano', symbol: 'ADA', image: 'https://assets.coingecko.com/coins/images/975/small/cardano.png' },
            { id: 'DOT', name: 'Polkadot', symbol: 'DOT', image: 'https://assets.coingecko.com/coins/images/12171/small/polkadot.png' }
        ];

        // Cache for token data
        let tokenDataCache = {};

        function showNotification() {
            const notification = document.getElementById('walletNotification');
            notification.classList.add('show');
            setTimeout(() => {
                hideNotification();
            }, 10000); // Hide after 10 seconds
        }

        function hideNotification() {
            const notification = document.getElementById('walletNotification');
            notification.classList.remove('show');
        }

        function showErrorNotification(message) {
            const notification = document.getElementById('errorNotification');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            notification.classList.add('show');
            setTimeout(() => {
                hideErrorNotification();
            }, 5000); // Hide after 5 seconds
        }

        function hideErrorNotification() {
            const notification = document.getElementById('errorNotification');
            notification.classList.remove('show');
        }

        // Add this function to handle auto reconnection
        async function attemptAutoReconnect() {
            if (autoReconnectAttempted) return;
            autoReconnectAttempted = true;

            try {
                if (window.solana && window.solana.isPhantom) {
                    wallet = window.solana;
                    
                    if (wallet.isConnected) {
                        await updateWalletUI(true);
                        return true;
                    }

                    try {
                        await wallet.connect({ onlyIfTrusted: true });
                        return true;
                    } catch (err) {
                        console.log('No trusted connection available');
                        return false;
                    }
                }
            } catch (err) {
                console.error('Auto reconnect failed:', err);
                showErrorNotification('Failed to reconnect wallet automatically');
                return false;
            }
            return false;
        }

        async function initWallet() {
            try {
                // Initialize Solana connection
                connection = new solanaWeb3.Connection(
                    solanaWeb3.clusterApiUrl('devnet'),
                    'confirmed'
                );

                // Check if Phantom is installed
                const isPhantomInstalled = window.solana && window.solana.isPhantom;
                
                // Update UI based on Phantom installation status
                const walletTitle = document.getElementById('walletTitle');
                const walletDescription = document.getElementById('walletDescription');
                const walletButtonText = document.getElementById('walletButtonText');
                const connectWalletBtn = document.getElementById('connectWalletBtn');

                if (!isPhantomInstalled) {
                    walletTitle.textContent = 'Install Phantom Wallet';
                    walletDescription.textContent = 'Install Phantom wallet to access the full features of the portal';
                    walletButtonText.textContent = 'Install Phantom';
                    connectWalletBtn.addEventListener('click', () => {
                        window.open('https://phantom.app/', '_blank');
                    });
                    return;
                }

                walletTitle.textContent = 'Connect Your Wallet';
                walletDescription.textContent = 'Connect your Solana wallet to access the full features of the portal';
                walletButtonText.textContent = 'Connect Wallet';
                
                wallet = window.solana;

                // Handle connection events
                wallet.on('connect', () => updateWalletUI(true));
                wallet.on('disconnect', () => updateWalletUI(false));

                // Attempt auto reconnect
                await attemptAutoReconnect();
            } catch (err) {
                console.error('Failed to initialize wallet:', err);
                showNotification();
            }
        }

        async function updateWalletUI(isConnected) {
            const walletConnectionSection = document.getElementById('walletConnectionSection');
            const tokenAnalysisSection = document.getElementById('tokenAnalysisSection');
            const walletStatus = document.querySelector('.wallet-status');
            const walletAddressShort = document.getElementById('walletAddressShort');
            
            if (isConnected && wallet.publicKey) {
                // Hide connection section, show analysis section
                walletConnectionSection.style.display = 'none';
                tokenAnalysisSection.style.display = 'block';
                
                // Show wallet status in top right
                walletStatus.style.display = 'flex';
                const address = wallet.publicKey.toString();
                walletAddressShort.textContent = `${address.slice(0, 4)}...${address.slice(-4)}`;
                
                // Store connection state
                localStorage.setItem('walletAutoConnect', 'true');
                
                // Load wallet balance
                loadWalletBalance();
                
                // Update error message
                const errorMessage = document.querySelector('.error-message');
                if (errorMessage) {
                    errorMessage.style.display = 'none';
                }

                // Update analytics when wallet is connected
                updateTokenAnalytics();
            } else {
                // Show connection section, hide analysis section
                walletConnectionSection.style.display = 'block';
                tokenAnalysisSection.style.display = 'none';
                
                // Hide wallet status
                walletStatus.style.display = 'none';
                walletAddressShort.textContent = '';
                
                // Clear stored connection state
                localStorage.removeItem('walletAutoConnect');
                
                // Reset balance and analytics
                document.getElementById('walletBalanceText').textContent = 'Please connect your wallet to view your balance';
                
                // Show error message
                const errorMessage = document.querySelector('.error-message');
                if (errorMessage) {
                    errorMessage.style.display = 'flex';
                }
            }
        }

        async function loadWalletBalance() {
            try {
                const balance = await connection.getBalance(wallet.publicKey);
                const solBalance = balance / solanaWeb3.LAMPORTS_PER_SOL;
                document.getElementById('walletBalanceText').textContent = `${solBalance.toFixed(4)} SOL`;
            } catch (err) {
                console.error('Failed to load balance:', err);
                document.getElementById('walletBalanceText').textContent = 'Failed to load balance';
                
                // Show error notification
                const notification = document.getElementById('errorNotification');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'Failed to load wallet balance. Please try again.';
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000);
            }
        }

        // Update the connect button click handler
        document.getElementById('connectWalletBtn').addEventListener('click', async () => {
            try {
                if (!wallet.isConnected) {
                    await wallet.connect();
                }
            } catch (err) {
                console.error('Failed to connect wallet:', err);
                const notification = document.getElementById('errorNotification');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'Failed to connect wallet. Please try again.';
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000);
            }
        });

        // Update the disconnect button click handler
        document.getElementById('disconnectWalletBtn').addEventListener('click', async () => {
            try {
                await wallet.disconnect();
                localStorage.removeItem('walletAutoConnect');
            } catch (err) {
                console.error('Failed to disconnect wallet:', err);
                const notification = document.getElementById('errorNotification');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'Failed to disconnect wallet. Please try again.';
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000);
            }
        });

        // Initialize wallet when page loads
        window.addEventListener('load', initWallet);

        // Sidebar toggle functionality
        document.querySelector('.sidebar-toggle').addEventListener('click', () => {
            document.body.classList.toggle('sidebar-collapsed');
        });

        // Tab functionality
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const tabId = item.getAttribute('data-tab');
                
                // Update active tab
                document.querySelectorAll('.nav-item').forEach(navItem => {
                    navItem.classList.remove('active');
                });
                item.classList.add('active');
                
                // Show active content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabId).classList.add('active');
            });
        });

        async function fetchTokenData() {
            try {
                // Get comma-separated list of token symbols
                const symbols = majorTokens.map(token => token.id).join(',');
                
                // Use Binance API as a backup
                const response = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbols=[${symbols}USDT]`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update cache with new data
                data.forEach(ticker => {
                    const symbol = ticker.symbol.replace('USDT', '');
                    const token = majorTokens.find(t => t.id === symbol);
                    if (token) {
                        tokenDataCache[token.id] = {
                            price: parseFloat(ticker.lastPrice),
                            priceChange: parseFloat(ticker.priceChangePercent),
                            marketCap: parseFloat(ticker.quoteVolume),
                            lastUpdate: Date.now()
                        };
                    }
                });

                return true;
            } catch (err) {
                console.error('Failed to fetch token data:', err);
                // Try CryptoCompare as fallback
                try {
                    const response = await fetch(`https://min-api.cryptocompare.com/data/pricemultifull?fsyms=${symbols}&tsyms=USD`);
                    const data = await response.json();
                    
                    if (data && data.RAW) {
                        majorTokens.forEach(token => {
                            if (data.RAW[token.id] && data.RAW[token.id].USD) {
                                tokenDataCache[token.id] = {
                                    price: data.RAW[token.id].USD.PRICE,
                                    priceChange: data.RAW[token.id].USD.CHANGEPCT24HOUR,
                                    marketCap: data.RAW[token.id].USD.MKTCAP,
                                    lastUpdate: Date.now()
                                };
                            }
                        });
                        return true;
                    }
                } catch (fallbackErr) {
                    console.error('Fallback API also failed:', fallbackErr);
                }
                return false;
            }
        }

        function createTokenCard(token) {
            return `
                <div class="token-card" data-token="${token.id}">
                    <div class="token-header">
                        <img src="${token.image}" alt="${token.name}" class="token-icon">
                        <h4>${token.name} (${token.symbol})</h4>
                    </div>
                    <div class="token-stats">
                        <p class="price">Price: Loading...</p>
                        <p class="change">24h: --</p>
                        <p class="market-cap">Market Cap: --</p>
                    </div>
                </div>
            `;
        }

        function updateTokenCardData(card, token) {
            const tokenData = tokenDataCache[token.id];
            if (!tokenData) {
                card.querySelector('.price').textContent = 'Price: Failed to load';
                card.querySelector('.change').textContent = '24h: --';
                card.querySelector('.market-cap').textContent = 'Market Cap: --';
                return;
            }

            const priceChangeColor = tokenData.priceChange >= 0 ? 'positive' : 'negative';
            const formattedPrice = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: tokenData.price < 1 ? 4 : 2,
                maximumFractionDigits: tokenData.price < 1 ? 4 : 2
            }).format(tokenData.price);
            
            const formattedMarketCap = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                notation: 'compact',
                maximumFractionDigits: 2
            }).format(tokenData.marketCap);

            // Update price with animation
            const priceElement = card.querySelector('.price');
            const oldPrice = parseFloat(priceElement.dataset.price || 0);
            const newPrice = tokenData.price;
            priceElement.dataset.price = newPrice;
            
            if (oldPrice && oldPrice !== newPrice) {
                priceElement.classList.add(newPrice > oldPrice ? 'price-up' : 'price-down');
                setTimeout(() => priceElement.classList.remove('price-up', 'price-down'), 1000);
            }
            
            priceElement.textContent = `Price: ${formattedPrice}`;

            // Update other stats
            const changeElement = card.querySelector('.change');
            changeElement.textContent = `24h: ${tokenData.priceChange.toFixed(2)}%`;
            changeElement.className = `change ${priceChangeColor}`;
            
            card.querySelector('.market-cap').textContent = `Market Cap: ${formattedMarketCap}`;
        }

        let isUpdating = false;
        let updateCount = 0;
        const MAX_FAST_UPDATES = 5;

        async function updateTokenAnalytics() {
            if (isUpdating) return;
            
            try {
                isUpdating = true;
                
                // Create cards if they don't exist
                const majorTokensContainer = document.getElementById('majorTokens');
                if (!majorTokensContainer.querySelector('.token-card')) {
                    majorTokensContainer.innerHTML = majorTokens.map(token => createTokenCard(token)).join('');
                }

                // Fetch new data
                const success = await fetchTokenData();

                if (success) {
                    // Update all cards with new data
                    majorTokens.forEach(token => {
                        const card = document.querySelector(`[data-token="${token.id}"]`);
                        if (card) {
                            updateTokenCardData(card, token);
                        }
                    });
                }

                // Adjust update interval based on update count
                updateCount++;
                if (updateCount === MAX_FAST_UPDATES) {
                    clearInterval(updateInterval);
                    setInterval(updateTokenAnalytics, 30000); // Switch to 30-second updates
                }

            } catch (err) {
                console.error('Failed to update token analytics:', err);
            } finally {
                isUpdating = false;
            }
        }

        // Initial load
        updateTokenAnalytics();

        // Start with fast updates (every 2 seconds)
        const updateInterval = setInterval(updateTokenAnalytics, 2000);

        // Add these functions before the analyzeToken function
        async function fetchDexScreenerData(address) {
            try {
                const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${address}`);
                if (!response.ok) throw new Error('DexScreener API request failed');
                const data = await response.json();
                
                // Get the most liquid pair
                const pairs = data.pairs || [];
                if (pairs.length === 0) return null;
                
                // Sort pairs by liquidity and get the most liquid one
                const mainPair = pairs.sort((a, b) => 
                    parseFloat(b.liquidity?.usd || 0) - parseFloat(a.liquidity?.usd || 0)
                )[0];

                return {
                    name: mainPair.baseToken.name,
                    symbol: mainPair.baseToken.symbol,
                    liquidity: {
                        usd: parseFloat(mainPair.liquidity?.usd || 0),
                        isLocked: mainPair.liquidity?.locked || false,
                        lockedAmount: mainPair.liquidity?.lockedAmount || "0",
                        lockedPercentage: mainPair.liquidity?.lockedPercentage || 0
                    },
                    volume: {
                        m5: parseFloat(mainPair.volume?.m5 || 0),
                        h1: parseFloat(mainPair.volume?.h1 || 0),
                        h6: parseFloat(mainPair.volume?.h6 || 0),
                        h24: parseFloat(mainPair.volume?.h24 || 0)
                    },
                    priceChange: {
                        m5: parseFloat(mainPair.priceChange?.m5 || 0),
                        h1: parseFloat(mainPair.priceChange?.h1 || 0),
                        h6: parseFloat(mainPair.priceChange?.h6 || 0),
                        h24: parseFloat(mainPair.priceChange?.h24 || 0)
                    }
                };
            } catch (err) {
                console.error('Failed to fetch DexScreener data:', err);
                return null;
            }
        }

        async function fetchSolscanData(address) {
            try {
                const [holdersResponse, metadataResponse, holderStatsResponse] = await Promise.all([
                    fetch(`https://public-api.solscan.io/token/holders?tokenAddress=${address}&limit=10&offset=0`),
                    fetch(`https://public-api.solscan.io/token/meta?tokenAddress=${address}`),
                    fetch(`https://public-api.solscan.io/token/holders/statistic?tokenAddress=${address}`)
                ]);

                if (!holdersResponse.ok || !metadataResponse.ok || !holderStatsResponse.ok) {
                    throw new Error('One or more Solscan API requests failed');
                }

                const [holdersData, metadata, holderStats] = await Promise.all([
                    holdersResponse.json(),
                    metadataResponse.json(),
                    holderStatsResponse.json()
                ]);

                return {
                    holders: {
                        total: holderStats.total || 0,
                        top10: holdersData.data?.slice(0, 10).map(holder => ({
                            address: holder.address,
                            amount: holder.amount,
                            percentage: holder.share
                        })) || [],
                        top10Percentage: holdersData.data?.slice(0, 10)
                            .reduce((sum, holder) => sum + parseFloat(holder.share || 0), 0) || 0
                    },
                    metadata: {
                        name: metadata.name,
                        symbol: metadata.symbol,
                        verified: metadata.verifiedCreator || false,
                        website: metadata.website || null
                    }
                };
            } catch (err) {
                console.error('Failed to fetch Solscan data:', err);
                return null;
            }
        }

        // Add helper function to format volume data
        function formatVolumeData(volume) {
            if (!volume) return "N/A";
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                notation: 'compact',
                maximumFractionDigits: 2
            }).format(volume);
        }

        async function fetchRugCheckData(address) {
            try {
                const response = await fetch(`https://api.rugcheck.xyz/v1/tokens/${address}/report`);
                if (!response.ok) throw new Error('RugCheck API request failed');
                const data = await response.json();
                return {
                    score: data.score || 0,
                    normalizedScore: data.score_normalised || 0,
                    risks: data.risks || [],
                    totalHolders: data.totalHolders || 0,
                    topHolders: data.topHolders || [],
                    markets: data.markets || [],
                    totalMarketLiquidity: data.totalMarketLiquidity || 0,
                    rugged: data.rugged || false,
                    transferFee: data.transferFee || { pct: 0, maxAmount: 0 }
                };
            } catch (err) {
                console.error('Failed to fetch RugCheck data:', err);
                return null;
            }
        }

        // Update the analyzeToken function
        async function analyzeToken(address) {
            try {
                const resultsDiv = document.getElementById('analysisResults');
                resultsDiv.innerHTML = '<div class="loading">Analyzing token...</div>';

                const [dexScreenerData, solscanData, rugCheckData] = await Promise.all([
                    fetchDexScreenerData(address),
                    fetchSolscanData(address),
                    fetchRugCheckData(address)
                ]);

                if (!dexScreenerData && !solscanData && !rugCheckData) {
                    throw new Error('Failed to fetch token data');
                }

                const metrics = [];
                const tokenName = solscanData?.metadata?.name || dexScreenerData?.name || "Unknown Token";
                const tokenSymbol = solscanData?.metadata?.symbol || dexScreenerData?.symbol;

                // Check if token name ends with "pump" for liquidity lock status
                const isPumpToken = tokenName.toLowerCase().endsWith('pump');

                // Risk Analysis from RugCheck
                if (rugCheckData) {
                    const riskScore = rugCheckData.normalizedScore;
                    metrics.push({
                        name: "Risk Analysis",
                        status: riskScore > 70 ? "healthy" : riskScore > 40 ? "warning" : "danger",
                        score: riskScore,
                        details: `
                            <div class="risk-analysis">
                                <div class="risk-header">
                                    <strong>Risk Score:</strong> ${riskScore}/100<br>
                                    <strong>Rugged:</strong> ${rugCheckData.rugged ? '⚠️ Yes' : '✅ No'}<br>
                                    ${rugCheckData.transferFee.pct > 0 ? 
                                        `<strong>Transfer Fee:</strong> ${rugCheckData.transferFee.pct}%<br>` : ''}
                                </div>
                                ${rugCheckData.risks.length > 0 ? `
                                    <div class="risk-warnings">
                                        <strong>Risk Warnings:</strong><br>
                                        ${rugCheckData.risks.map(risk => `
                                            <div class="risk-item ${risk.level}">
                                                • ${risk.name}${risk.description ? `: ${risk.description}` : ''}
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                                <div class="market-info">
                                    <strong>Total Market Liquidity:</strong> ${formatVolumeData(rugCheckData.totalMarketLiquidity)}<br>
                                    <strong>Total Holders:</strong> ${rugCheckData.totalHolders?.toLocaleString() || 'N/A'}
                                </div>
                            </div>
                        `
                    });
                }

                // Liquidity Analysis
                if (dexScreenerData?.liquidity) {
                    const liquidity = dexScreenerData.liquidity;
                    if (isPumpToken) {
                        liquidity.isLocked = true;
                        liquidity.lockedPercentage = 100;
                    }
                    
                    metrics.push({
                        name: "Liquidity",
                        status: liquidity.usd > 100000 ? "healthy" : liquidity.usd > 50000 ? "warning" : "danger",
                        score: Math.min(100, Math.round((liquidity.usd / 100000) * 100)),
                        details: `
                            Amount: $${liquidity.usd.toLocaleString()}<br>
                            Status: ${liquidity.isLocked ? '🔒 Locked' : '🔓 Unlocked'}${isPumpToken ? ' (Pump Token)' : ''}<br>
                            ${liquidity.isLocked ? `Locked Amount: $${liquidity.usd.toLocaleString()}<br>
                            Locked Percentage: ${isPumpToken ? '100' : liquidity.lockedPercentage}%` : ''}
                        `
                    });
                }

                // Top 10 Holders (Separate from general holder distribution)
                if (solscanData?.holders) {
                    const holders = solscanData.holders;
                    metrics.push({
                        name: "Top 10 Holders",
                        status: holders.top10Percentage < 50 ? "healthy" : holders.top10Percentage < 70 ? "warning" : "danger",
                        score: Math.max(0, 100 - Math.round(holders.top10Percentage)),
                        details: `
                            <div class="holder-list">
                                <div class="holder-header">
                                    <strong>Total Holders:</strong> ${holders.total.toLocaleString()}<br>
                                    <strong>Combined Top 10:</strong> ${holders.top10Percentage.toFixed(2)}%
                                </div>
                                <div class="holder-table">
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Rank</th>
                                                <th>Address</th>
                                                <th>Percentage</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${holders.top10.map((holder, i) => `
                                                <tr>
                                                    <td>#${i + 1}</td>
                                                    <td><a href="https://solscan.io/account/${holder.address}" target="_blank">${holder.address.substring(0, 6)}...${holder.address.substring(holder.address.length - 4)}</a></td>
                                                    <td>${holder.percentage.toFixed(2)}%</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        `
                    });
                }

                // Volume Analysis
                if (dexScreenerData?.volume) {
                    const volume = dexScreenerData.volume;
                    const volumeScore = Math.min(100, Math.round((volume.h24 / 50000) * 100));
                    metrics.push({
                        name: "Trading Volume",
                        status: volumeScore > 80 ? "healthy" : volumeScore > 40 ? "warning" : "danger",
                        score: volumeScore,
                        details: `
                            5M: ${formatVolumeData(volume.m5)}<br>
                            1H: ${formatVolumeData(volume.h1)}<br>
                            6H: ${formatVolumeData(volume.h6)}<br>
                            24H: ${formatVolumeData(volume.h24)}
                        `
                    });
                }

                // Contract Safety
                if (solscanData?.metadata) {
                    const metadata = solscanData.metadata;
                    const safetyScore = (metadata.verified ? 50 : 0) + (metadata.website ? 30 : 0);
                    
                    metrics.push({
                        name: "Contract Safety",
                        status: safetyScore > 70 ? "healthy" : safetyScore > 40 ? "warning" : "danger",
                        score: safetyScore,
                        details: `
                            ${metadata.verified ? '✓' : '✗'} Verified Contract<br>
                            ${metadata.website ? '✓' : '✗'} Website Present<br>
                            ${metadata.website ? `Website: ${metadata.website}` : ''}
                        `
                    });
                }

                // Display results
                displayAnalysisResults({
                    tokenName: tokenName,
                    tokenSymbol: tokenSymbol,
                    metrics: metrics
                });

            } catch (err) {
                console.error('Failed to analyze token:', err);
                resultsDiv.innerHTML = `
                    <div class="analysis-error">
                        <svg viewBox="0 0 24 24" width="24" height="24">
                            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                        </svg>
                        <p>Failed to analyze token. Please verify the contract address and try again.</p>
                    </div>
                `;
            }
        }

        // Update the displayAnalysisResults function
        function displayAnalysisResults(results) {
            const resultsDiv = document.getElementById('analysisResults');
            
            const html = `
                <div class="analysis-card">
                    <div class="token-header">
                        <h3>${results.tokenName} ${results.tokenSymbol ? `(${results.tokenSymbol})` : ''}</h3>
                    </div>
                    <div class="metrics-grid">
                        ${results.metrics.map(metric => `
                            <div class="metric-card ${metric.status}">
                                <h4>${metric.name}</h4>
                                <div class="score-circle">
                                    <span>${metric.score}</span>
                                </div>
                                <p class="status-text">${metric.status.charAt(0).toUpperCase() + metric.status.slice(1)}</p>
                                ${metric.details ? `<div class="metric-details">${metric.details}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            resultsDiv.innerHTML = html;
        }

        // Add event listener for token analysis
        document.getElementById('analyzeTokenBtn').addEventListener('click', () => {
            const address = document.getElementById('tokenAddress').value.trim();
            if (address) {
                analyzeToken(address);
            } else {
                showErrorNotification('Please enter a valid token address');
            }
        });
    </script>
</body>
</html>
