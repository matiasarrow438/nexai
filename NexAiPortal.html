<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEX.AI Portal</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" href="favicon.png">
    
    <!-- Solana Dependencies -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-base"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-wallets"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-phantom"></script>
</head>
<body class="with-sidebar">
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="index.html" class="logo-link">
                <svg class="logo" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    
                    <!-- Outer hexagon -->
                    <path d="M50 20 L75 32.5 L75 67.5 L50 80 L25 67.5 L25 32.5 Z" 
                          stroke="#00a2ff" 
                          stroke-width="2"
                          fill="none"
                          stroke-linecap="round"
                          filter="url(#glow)"/>
                          
                    <!-- Inner geometric pattern -->
                    <path d="M50 35 L65 42.5 L65 57.5 L50 65 L35 57.5 L35 42.5 Z" 
                          stroke="#00a2ff" 
                          stroke-width="2"
                          fill="none"
                          stroke-linecap="round"
                          filter="url(#glow)"/>
                          
                    <!-- Center connecting lines -->
                    <path d="M50 35 L50 20 M35 42.5 L25 32.5 M65 42.5 L75 32.5" 
                          stroke="#00a2ff" 
                          stroke-width="2"
                          fill="none"
                          stroke-linecap="round"
                          filter="url(#glow)"/>
                </svg>
            </a>
            <button class="sidebar-toggle">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>
                </svg>
            </button>
        </div>
        <nav class="sidebar-nav">
            <a href="#dashboard" class="nav-item active" data-tab="dashboard">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/>
                </svg>
                <span class="nav-item-text">Dashboard</span>
            </a>
            <a href="#wallet" class="nav-item" data-tab="wallet">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>
                </svg>
                <span class="nav-item-text">Wallet</span>
            </a>
            <a href="#analytics" class="nav-item" data-tab="analytics">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <path fill="currentColor" d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"/>
                </svg>
                <span class="nav-item-text">Analytics</span>
            </a>
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Add this right after <main class="main-content"> -->
        <div class="top-bar">
            <div class="wallet-status" style="display: none;">
                <span id="walletAddressShort"></span>
                <button class="disconnect-btn" id="disconnectWalletBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                        <path d="M16 13v-2H7V8l-5 4 5 4v-3h9zm-1-7h6v12h-6v2h6a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-6v2z" fill="currentColor"/>
                    </svg>
                    Disconnect
                </button>
            </div>
        </div>

        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboard">
            <div class="wallet-connection" id="walletConnectionSection">
                <div class="wallet-icon">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none">
                        <path d="M19 7h-1V6a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-3-2v2H5a1 1 0 0 1 0-2h11zm4 12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8.83A3 3 0 0 0 5 9h14a1 1 0 0 1 1 1v7z" fill="currentColor"/>
                        <path d="M16 11.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z" fill="currentColor"/>
                    </svg>
                </div>
                <h1 id="walletTitle">Connect Your Wallet</h1>
                <p id="walletDescription">Connect your Solana wallet to access the full features of the portal</p>
                <div class="wallet-button-container">
                    <button class="wallet-connect-btn" id="connectWalletBtn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M19 7h-1V6a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-3-2v2H5a1 1 0 0 1 0-2h11zm4 12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8.83A3 3 0 0 0 5 9h14a1 1 0 0 1 1 1v7z" fill="currentColor"/>
                            <path d="M16 11.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z" fill="currentColor"/>
                        </svg>
                        <span id="walletButtonText">Connect Wallet</span>
                    </button>
                </div>
            </div>

            <!-- Token Analysis Section (shown after wallet connection) -->
            <div class="token-analysis" id="tokenAnalysisSection" style="display: none;">
                <div class="token-input-section">
                    <h2>Token Analysis</h2>
                    <p>Enter a token contract address to analyze its health and investment potential</p>
                    <div class="token-input-container">
                        <input type="text" id="tokenAddress" placeholder="Enter token contract address" class="token-input">
                        <button class="analyze-btn" id="analyzeTokenBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                                <path d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 1 0-.7.7l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0A4.5 4.5 0 1 1 14 9.5 4.5 4.5 0 0 1 9.5 14z" fill="currentColor"/>
                            </svg>
                            Analyze
                        </button>
                    </div>
                </div>

                <div class="analysis-results" id="analysisResults">
                    <!-- Results will be populated here -->
                </div>
            </div>
        </div>

        <!-- Wallet Tab -->
        <div class="tab-content" id="wallet">
            <div class="wallet-balance">
                <h2>Wallet Balance</h2>
                <p id="walletBalanceText">Please connect your wallet to view your balance</p>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div class="tab-content" id="analytics">
            <div class="analytics-data">
                <h2>Market Analytics</h2>
                <div class="token-sections">
                    <!-- Major Cryptocurrencies -->
                    <div class="token-section">
                        <h3>Major Cryptocurrencies</h3>
                        <div class="token-grid" id="majorTokens">
                            <div class="token-card loading">
                                <div class="token-header">
                                    <div class="token-icon-placeholder"></div>
                                    <h4>Loading...</h4>
                                </div>
                                <div class="token-stats">
                                    <p class="price">Price: Loading...</p>
                                    <p class="change">24h: Loading...</p>
                                    <p class="market-cap">Market Cap: Loading...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Error Message -->
    <div class="error-message">
        <svg viewBox="0 0 24 24" width="16" height="16">
            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
        </svg>
        <span>Please connect your wallet</span>
    </div>

    <!-- Add this before the closing body tag -->
    <div class="notification" id="walletNotification">
        <svg class="notification-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M21 7h-1V6a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-8a3 3 0 0 0-3-3zm-3-2v2H5a1 1 0 0 1 0-2h11zm4 12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8.83A3 3 0 0 0 5 9h14a1 1 0 0 1 1 1v7z"/>
            <path fill="currentColor" d="M16 11.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
        </svg>
        <div class="notification-content">
            <div class="notification-title">Wallet Required</div>
            <div class="notification-message">Please install Phantom wallet to use all features</div>
        </div>
        <button class="notification-action" onclick="window.open('https://phantom.app/', '_blank')">Install Phantom</button>
        <button class="notification-close" onclick="hideNotification()">✕</button>
    </div>

    <!-- Add this before the closing body tag -->
    <div class="notification error" id="errorNotification">
        <svg class="notification-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
        </svg>
        <div class="notification-content">
            <div class="notification-title">Connection Error</div>
            <div class="notification-message" id="errorMessage">Failed to connect wallet</div>
        </div>
        <button class="notification-close" onclick="hideErrorNotification()">✕</button>
    </div>

    <script>
        let wallet = null;
        let connection = null;
        let autoReconnectAttempted = false;

        // Token lists with IDs and static image URLs
        const majorTokens = [
            { id: 'BTC', name: 'Bitcoin', symbol: 'BTC', image: 'https://assets.coingecko.com/coins/images/1/small/bitcoin.png' },
            { id: 'ETH', name: 'Ethereum', symbol: 'ETH', image: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
            { id: 'SOL', name: 'Solana', symbol: 'SOL', image: 'https://assets.coingecko.com/coins/images/4128/small/solana.png' },
            { id: 'LTC', name: 'Litecoin', symbol: 'LTC', image: 'https://assets.coingecko.com/coins/images/2/small/litecoin.png' },
            { id: 'ADA', name: 'Cardano', symbol: 'ADA', image: 'https://assets.coingecko.com/coins/images/975/small/cardano.png' },
            { id: 'DOT', name: 'Polkadot', symbol: 'DOT', image: 'https://assets.coingecko.com/coins/images/12171/small/polkadot.png' }
        ];

        // Cache for token data
        let tokenDataCache = {};

        function showNotification() {
            const notification = document.getElementById('walletNotification');
            notification.classList.add('show');
            setTimeout(() => {
                hideNotification();
            }, 10000); // Hide after 10 seconds
        }

        function hideNotification() {
            const notification = document.getElementById('walletNotification');
            notification.classList.remove('show');
        }

        function showErrorNotification(message) {
            const notification = document.getElementById('errorNotification');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            notification.classList.add('show');
            setTimeout(() => {
                hideErrorNotification();
            }, 5000); // Hide after 5 seconds
        }

        function hideErrorNotification() {
            const notification = document.getElementById('errorNotification');
            notification.classList.remove('show');
        }

        // Add this function to handle auto reconnection
        async function attemptAutoReconnect() {
            if (autoReconnectAttempted) return;
            autoReconnectAttempted = true;

            try {
                if (window.solana && window.solana.isPhantom) {
                    wallet = window.solana;
                    
                    if (wallet.isConnected) {
                        await updateWalletUI(true);
                        return true;
                    }

                    try {
                        await wallet.connect({ onlyIfTrusted: true });
                        return true;
                    } catch (err) {
                        console.log('No trusted connection available');
                        return false;
                    }
                }
            } catch (err) {
                console.error('Auto reconnect failed:', err);
                showErrorNotification('Failed to reconnect wallet automatically');
                return false;
            }
            return false;
        }

        async function initWallet() {
            try {
                // Initialize Solana connection
                connection = new solanaWeb3.Connection(
                    solanaWeb3.clusterApiUrl('devnet'),
                    'confirmed'
                );

                // Check if Phantom is installed
                const isPhantomInstalled = window.solana && window.solana.isPhantom;
                
                // Update UI based on Phantom installation status
                const walletTitle = document.getElementById('walletTitle');
                const walletDescription = document.getElementById('walletDescription');
                const walletButtonText = document.getElementById('walletButtonText');
                const connectWalletBtn = document.getElementById('connectWalletBtn');

                if (!isPhantomInstalled) {
                    walletTitle.textContent = 'Install Phantom Wallet';
                    walletDescription.textContent = 'Install Phantom wallet to access the full features of the portal';
                    walletButtonText.textContent = 'Install Phantom';
                    connectWalletBtn.addEventListener('click', () => {
                        window.open('https://phantom.app/', '_blank');
                    });
                    return;
                }

                walletTitle.textContent = 'Connect Your Wallet';
                walletDescription.textContent = 'Connect your Solana wallet to access the full features of the portal';
                walletButtonText.textContent = 'Connect Wallet';
                
                wallet = window.solana;

                // Handle connection events
                wallet.on('connect', () => updateWalletUI(true));
                wallet.on('disconnect', () => updateWalletUI(false));

                // Attempt auto reconnect
                await attemptAutoReconnect();
            } catch (err) {
                console.error('Failed to initialize wallet:', err);
                showNotification();
            }
        }

        async function updateWalletUI(isConnected) {
            const walletConnectionSection = document.getElementById('walletConnectionSection');
            const tokenAnalysisSection = document.getElementById('tokenAnalysisSection');
            const walletStatus = document.querySelector('.wallet-status');
            const walletAddressShort = document.getElementById('walletAddressShort');
            
            if (isConnected && wallet.publicKey) {
                // Hide connection section, show analysis section
                walletConnectionSection.style.display = 'none';
                tokenAnalysisSection.style.display = 'block';
                
                // Show wallet status in top right
                walletStatus.style.display = 'flex';
                const address = wallet.publicKey.toString();
                walletAddressShort.textContent = `${address.slice(0, 4)}...${address.slice(-4)}`;
                
                // Store connection state
                localStorage.setItem('walletAutoConnect', 'true');
                
                // Load wallet balance
                loadWalletBalance();
                
                // Update error message
                const errorMessage = document.querySelector('.error-message');
                if (errorMessage) {
                    errorMessage.style.display = 'none';
                }

                // Update analytics when wallet is connected
                updateTokenAnalytics();
            } else {
                // Show connection section, hide analysis section
                walletConnectionSection.style.display = 'block';
                tokenAnalysisSection.style.display = 'none';
                
                // Hide wallet status
                walletStatus.style.display = 'none';
                walletAddressShort.textContent = '';
                
                // Clear stored connection state
                localStorage.removeItem('walletAutoConnect');
                
                // Reset balance and analytics
                document.getElementById('walletBalanceText').textContent = 'Please connect your wallet to view your balance';
                
                // Show error message
                const errorMessage = document.querySelector('.error-message');
                if (errorMessage) {
                    errorMessage.style.display = 'flex';
                }
            }
        }

        async function loadWalletBalance() {
            try {
                const balance = await connection.getBalance(wallet.publicKey);
                const solBalance = balance / solanaWeb3.LAMPORTS_PER_SOL;
                document.getElementById('walletBalanceText').textContent = `${solBalance.toFixed(4)} SOL`;
            } catch (err) {
                console.error('Failed to load balance:', err);
                document.getElementById('walletBalanceText').textContent = 'Failed to load balance';
                
                // Show error notification
                const notification = document.getElementById('errorNotification');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'Failed to load wallet balance. Please try again.';
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000);
            }
        }

        // Update the connect button click handler
        document.getElementById('connectWalletBtn').addEventListener('click', async () => {
            try {
                if (!wallet.isConnected) {
                    await wallet.connect();
                }
            } catch (err) {
                console.error('Failed to connect wallet:', err);
                const notification = document.getElementById('errorNotification');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'Failed to connect wallet. Please try again.';
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000);
            }
        });

        // Update the disconnect button click handler
        document.getElementById('disconnectWalletBtn').addEventListener('click', async () => {
            try {
                await wallet.disconnect();
                localStorage.removeItem('walletAutoConnect');
            } catch (err) {
                console.error('Failed to disconnect wallet:', err);
                const notification = document.getElementById('errorNotification');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = 'Failed to disconnect wallet. Please try again.';
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 5000);
            }
        });

        // Initialize wallet when page loads
        window.addEventListener('load', initWallet);

        // Sidebar toggle functionality
        document.querySelector('.sidebar-toggle').addEventListener('click', () => {
            document.body.classList.toggle('sidebar-collapsed');
        });

        // Tab functionality
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const tabId = item.getAttribute('data-tab');
                
                // Update active tab
                document.querySelectorAll('.nav-item').forEach(navItem => {
                    navItem.classList.remove('active');
                });
                item.classList.add('active');
                
                // Show active content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabId).classList.add('active');
            });
        });

        async function fetchTokenData() {
            try {
                // Get comma-separated list of token symbols
                const symbols = majorTokens.map(token => token.id).join(',');
                
                // Use Binance API as a backup
                const response = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbols=[${symbols}USDT]`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update cache with new data
                data.forEach(ticker => {
                    const symbol = ticker.symbol.replace('USDT', '');
                    const token = majorTokens.find(t => t.id === symbol);
                    if (token) {
                        tokenDataCache[token.id] = {
                            price: parseFloat(ticker.lastPrice),
                            priceChange: parseFloat(ticker.priceChangePercent),
                            marketCap: parseFloat(ticker.quoteVolume),
                            lastUpdate: Date.now()
                        };
                    }
                });

                return true;
            } catch (err) {
                console.error('Failed to fetch token data:', err);
                // Try CryptoCompare as fallback
                try {
                    const response = await fetch(`https://min-api.cryptocompare.com/data/pricemultifull?fsyms=${symbols}&tsyms=USD`);
                    const data = await response.json();
                    
                    if (data && data.RAW) {
                        majorTokens.forEach(token => {
                            if (data.RAW[token.id] && data.RAW[token.id].USD) {
                                tokenDataCache[token.id] = {
                                    price: data.RAW[token.id].USD.PRICE,
                                    priceChange: data.RAW[token.id].USD.CHANGEPCT24HOUR,
                                    marketCap: data.RAW[token.id].USD.MKTCAP,
                                    lastUpdate: Date.now()
                                };
                            }
                        });
                        return true;
                    }
                } catch (fallbackErr) {
                    console.error('Fallback API also failed:', fallbackErr);
                }
                return false;
            }
        }

        function createTokenCard(token) {
            return `
                <div class="token-card" data-token="${token.id}">
                    <div class="token-header">
                        <img src="${token.image}" alt="${token.name}" class="token-icon">
                        <h4>${token.name} (${token.symbol})</h4>
                    </div>
                    <div class="token-stats">
                        <p class="price">Price: Loading...</p>
                        <p class="change">24h: --</p>
                        <p class="market-cap">Market Cap: --</p>
                    </div>
                </div>
            `;
        }

        function updateTokenCardData(card, token) {
            const tokenData = tokenDataCache[token.id];
            if (!tokenData) {
                card.querySelector('.price').textContent = 'Price: Failed to load';
                card.querySelector('.change').textContent = '24h: --';
                card.querySelector('.market-cap').textContent = 'Market Cap: --';
                return;
            }

            const priceChangeColor = tokenData.priceChange >= 0 ? 'positive' : 'negative';
            const formattedPrice = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: tokenData.price < 1 ? 4 : 2,
                maximumFractionDigits: tokenData.price < 1 ? 4 : 2
            }).format(tokenData.price);
            
            const formattedMarketCap = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                notation: 'compact',
                maximumFractionDigits: 2
            }).format(tokenData.marketCap);

            // Update price with animation
            const priceElement = card.querySelector('.price');
            const oldPrice = parseFloat(priceElement.dataset.price || 0);
            const newPrice = tokenData.price;
            priceElement.dataset.price = newPrice;
            
            if (oldPrice && oldPrice !== newPrice) {
                priceElement.classList.add(newPrice > oldPrice ? 'price-up' : 'price-down');
                setTimeout(() => priceElement.classList.remove('price-up', 'price-down'), 1000);
            }
            
            priceElement.textContent = `Price: ${formattedPrice}`;

            // Update other stats
            const changeElement = card.querySelector('.change');
            changeElement.textContent = `24h: ${tokenData.priceChange.toFixed(2)}%`;
            changeElement.className = `change ${priceChangeColor}`;
            
            card.querySelector('.market-cap').textContent = `Market Cap: ${formattedMarketCap}`;
        }

        let isUpdating = false;
        let updateCount = 0;
        const MAX_FAST_UPDATES = 5;

        async function updateTokenAnalytics() {
            if (isUpdating) return;
            
            try {
                isUpdating = true;
                
                // Create cards if they don't exist
                const majorTokensContainer = document.getElementById('majorTokens');
                if (!majorTokensContainer.querySelector('.token-card')) {
                    majorTokensContainer.innerHTML = majorTokens.map(token => createTokenCard(token)).join('');
                }

                // Fetch new data
                const success = await fetchTokenData();

                if (success) {
                    // Update all cards with new data
                    majorTokens.forEach(token => {
                        const card = document.querySelector(`[data-token="${token.id}"]`);
                        if (card) {
                            updateTokenCardData(card, token);
                        }
                    });
                }

                // Adjust update interval based on update count
                updateCount++;
                if (updateCount === MAX_FAST_UPDATES) {
                    clearInterval(updateInterval);
                    setInterval(updateTokenAnalytics, 30000); // Switch to 30-second updates
                }

            } catch (err) {
                console.error('Failed to update token analytics:', err);
            } finally {
                isUpdating = false;
            }
        }

        // Initial load
        updateTokenAnalytics();

        // Start with fast updates (every 2 seconds)
        const updateInterval = setInterval(updateTokenAnalytics, 2000);

        // Add these functions before the analyzeToken function
        async function fetchDexScreenerData(address) {
            try {
                const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${address}`);
                if (!response.ok) throw new Error('DexScreener API request failed');
                const data = await response.json();
                
                // Get the most liquid pair
                const pairs = data.pairs || [];
                if (pairs.length === 0) return null;
                
                // Sort pairs by liquidity and get the most liquid one
                const mainPair = pairs.sort((a, b) => 
                    parseFloat(b.liquidity?.usd || 0) - parseFloat(a.liquidity?.usd || 0)
                )[0];

                return {
                    name: mainPair.baseToken.name,
                    symbol: mainPair.baseToken.symbol,
                    liquidity: {
                        usd: parseFloat(mainPair.liquidity?.usd || 0),
                        isLocked: mainPair.liquidity?.locked || false,
                        lockedAmount: mainPair.liquidity?.lockedAmount || "0",
                        lockedPercentage: mainPair.liquidity?.lockedPercentage || 0
                    },
                    volume: {
                        m5: parseFloat(mainPair.volume?.m5 || 0),
                        h1: parseFloat(mainPair.volume?.h1 || 0),
                        h6: parseFloat(mainPair.volume?.h6 || 0),
                        h24: parseFloat(mainPair.volume?.h24 || 0)
                    },
                    priceChange: {
                        m5: parseFloat(mainPair.priceChange?.m5 || 0),
                        h1: parseFloat(mainPair.priceChange?.h1 || 0),
                        h6: parseFloat(mainPair.priceChange?.h6 || 0),
                        h24: parseFloat(mainPair.priceChange?.h24 || 0)
                    }
                };
            } catch (err) {
                console.error('Failed to fetch DexScreener data:', err);
                return null;
            }
        }

        async function fetchSolscanData(address) {
            try {
                const [holdersResponse, metadataResponse, holderStatsResponse] = await Promise.all([
                    fetch(`https://public-api.solscan.io/token/holders?tokenAddress=${address}&limit=10&offset=0`),
                    fetch(`https://public-api.solscan.io/token/meta?tokenAddress=${address}`),
                    fetch(`https://public-api.solscan.io/token/holders/statistic?tokenAddress=${address}`)
                ]);

                if (!holdersResponse.ok || !metadataResponse.ok || !holderStatsResponse.ok) {
                    throw new Error('One or more Solscan API requests failed');
                }

                const [holdersData, metadata, holderStats] = await Promise.all([
                    holdersResponse.json(),
                    metadataResponse.json(),
                    holderStatsResponse.json()
                ]);

                return {
                    holders: {
                        total: holderStats.total || 0,
                        top10: holdersData.data?.slice(0, 10).map(holder => ({
                            address: holder.address,
                            amount: holder.amount,
                            percentage: holder.share
                        })) || [],
                        top10Percentage: holdersData.data?.slice(0, 10)
                            .reduce((sum, holder) => sum + parseFloat(holder.share || 0), 0) || 0
                    },
                    metadata: {
                        name: metadata.name,
                        symbol: metadata.symbol,
                        verified: metadata.verifiedCreator || false,
                        website: metadata.website || null
                    }
                };
            } catch (err) {
                console.error('Failed to fetch Solscan data:', err);
                return null;
            }
        }

        // Add helper function to format volume data
        function formatVolumeData(volume) {
            if (!volume) return "N/A";
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                notation: 'compact',
                maximumFractionDigits: 2
            }).format(volume);
        }

        async function fetchRugCheckData(address) {
            try {
                const response = await fetch(`https://api.rugcheck.xyz/v1/tokens/${address}/report`);
                if (!response.ok) throw new Error('RugCheck API request failed');
                const data = await response.json();
                return {
                    token: data.token || {},
                    tokenMeta: data.tokenMeta || {},
                    topHolders: data.topHolders || [],
                    risks: data.risks || [],
                    score: data.score || 0,
                    score_normalised: data.score_normalised || 0,
                    markets: data.markets || [],
                    totalMarketLiquidity: data.totalMarketLiquidity || 0,
                    totalLPProviders: data.totalLPProviders || 0,
                    totalHolders: data.totalHolders || 0,
                    price: data.price || 0,
                    rugged: data.rugged || false,
                    transferFee: data.transferFee || { pct: 0, maxAmount: 0 },
                    knownAccounts: data.knownAccounts || {},
                    lockerOwners: data.lockerOwners || {},
                    lockers: data.lockers || {}
                };
            } catch (err) {
                console.error('Failed to fetch RugCheck data:', err);
                return null;
            }
        }

        async function fetchBundleData(address) {
            try {
                console.log('Fetching bundle data for:', address);
                
                // First try the bundle_advanced endpoint
                let response = await fetch(`https://trench.bot/api/bundle_advanced/${address}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Origin': 'https://trench.bot',
                        'Referer': 'https://trench.bot/'
                    }
                });
                
                // If that fails, try the regular bundle endpoint
                if (!response.ok) {
                    console.log('Bundle advanced API failed, trying regular bundle endpoint');
                    response = await fetch(`https://trench.bot/api/bundle/${address}`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'Origin': 'https://trench.bot',
                            'Referer': 'https://trench.bot/'
                        }
                    });
                }
                
                console.log('Bundle API response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Bundle API error:', errorText);
                    throw new Error(`Bundle API request failed with status ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Bundle data received:', data);
                
                // Handle both advanced and regular bundle response formats
                return {
                    is_bundled: data.is_bundled || data.bundled || false,
                    bundle_size: data.bundle_size || data.size || '0',
                    bundle_type: data.bundle_type || data.type || 'N/A',
                    bundle_expiry: data.bundle_expiry || data.expiry || null
                };
            } catch (err) {
                console.error('Failed to fetch bundle data:', err);
                return null;
            }
        }

        // Update the analyzeToken function
        async function analyzeToken(address) {
            try {
                const resultsDiv = document.getElementById('analysisResults');
                resultsDiv.innerHTML = '<div class="loading">Analyzing token...</div>';

                const [rugCheckData, bundleData] = await Promise.all([
                    fetchRugCheckData(address),
                    fetchBundleData(address)
                ]);

                if (!rugCheckData) {
                    throw new Error('Failed to fetch token data');
                }

                const metrics = [];

                // Risk Analysis
                metrics.push({
                    name: "Risk Analysis",
                    status: rugCheckData.score_normalised > 70 ? "healthy" : rugCheckData.score_normalised > 40 ? "warning" : "danger",
                    score: rugCheckData.score_normalised,
                    details: `
                        <div class="risk-analysis">
                            ${rugCheckData.risks.length > 0 ? `
                                <div class="risk-warnings">
                                    <strong>Risk Warnings:</strong><br>
                                    ${rugCheckData.risks.map(risk => `
                                        <div class="risk-item ${risk.level}">
                                            • ${risk.name}${risk.description ? `: ${risk.description}` : ''}<br>
                                            ${risk.score ? `Score Impact: ${risk.score}` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '<div class="risk-warnings">No specific risks detected</div>'}
                        </div>
                    `
                });

                // Display results with rugcheck and bundle data
                displayAnalysisResults({
                    metrics: metrics,
                    rugCheckData: rugCheckData,
                    bundleData: bundleData
                });

            } catch (err) {
                console.error('Failed to analyze token:', err);
                resultsDiv.innerHTML = `
                    <div class="analysis-error">
                        <svg viewBox="0 0 24 24" width="24" height="24">
                            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                        </svg>
                        <p>Failed to analyze token. Please verify the contract address and try again.</p>
                    </div>
                `;
            }
        }

        // Update the displayAnalysisResults function
        function displayAnalysisResults(results) {
            const resultsDiv = document.getElementById('analysisResults');
            
            // Convert rugcheck score to scale with more detailed criteria
            function getScaleFromScore(score, rugged, risks, rugCheckData) {
                // If token is marked as rugged
                if (rugged) return { text: 'TERRIBLE', class: 'terrible', reason: 'Token is marked as rugged' };
                
                // Count high and medium severity risks
                const highRisks = risks.filter(risk => risk.level === 'high');
                const mediumRisks = risks.filter(risk => risk.level === 'medium');
                
                // Check for critical conditions
                if (highRisks.length > 2) {
                    return { text: 'TERRIBLE', class: 'terrible', reason: 'Multiple high-risk issues detected' };
                }
                
                // Check for specific high-risk conditions
                const hasOwnershipRisk = highRisks.some(risk => risk.name.toLowerCase().includes('ownership'));
                const hasLiquidityRisk = highRisks.some(risk => risk.name.toLowerCase().includes('liquidity'));
                
                if (hasOwnershipRisk || hasLiquidityRisk) {
                    return { text: 'TERRIBLE', class: 'terrible', reason: 'Critical ownership or liquidity risks detected' };
                }
                
                // Score-based rating with risk factors
                if (score >= 70 && highRisks.length === 0) {
                    return { text: 'REALLY GOOD', class: 'really-good', reason: 'High score with no major risks' };
                }
                if (score >= 50 && highRisks.length <= 1) {
                    return { text: 'GOOD', class: 'good', reason: 'Good score with minimal risks' };
                }
                if (score >= 30 || mediumRisks.length <= 2) {
                    return { text: 'BAD', class: 'bad', reason: 'Low score or multiple medium risks' };
                }
                
                return { text: 'TERRIBLE', class: 'terrible', reason: 'Very low score and multiple risks' };
            }

            const riskMetric = results.metrics.find(m => m.name === "Risk Analysis");
            const riskScore = riskMetric?.score || 0;
            const rugCheckData = results.rugCheckData;
            const riskScale = getScaleFromScore(riskScore, rugCheckData?.rugged, rugCheckData?.risks || [], rugCheckData);
            
            const html = `
                <div class="analysis-card">
                    <div class="risk-overview">
                        <div class="risk-score">
                            <h2>Risk Analysis</h2>
                            <div class="risk-label ${riskScale.class}">
                                ${riskScale.text}
                                ${riskScale.reason ? `<div class="risk-reason">${riskScale.reason}</div>` : ''}
                            </div>
                        </div>
                        <div class="risk-warnings">
                            ${results.metrics.find(m => m.name === "Risk Analysis")?.details || ''}
                        </div>
                    </div>

                    <div class="bundle-info">
                        <h2>Bundle Status</h2>
                        <div class="bundle-details">
                            ${results.bundleData ? `
                                <div class="bundle-status ${results.bundleData.is_bundled ? 'bundled' : 'not-bundled'}">
                                    <div class="status-icon">${results.bundleData.is_bundled ? '✓' : '✗'}</div>
                                    <div class="status-text">
                                        <span class="status-label">${results.bundleData.is_bundled ? 'BUNDLED' : 'NOT BUNDLED'}</span>
                                        ${results.bundleData.is_bundled ? `
                                            <div class="bundle-details-text">
                                                <p>Bundle Size: ${results.bundleData.bundle_size}</p>
                                                <p>Bundle Type: ${results.bundleData.bundle_type}</p>
                                                ${results.bundleData.bundle_expiry ? `<p>Expires: ${new Date(results.bundleData.bundle_expiry).toLocaleDateString()}</p>` : ''}
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            ` : '<div class="bundle-error">Unable to fetch bundle information</div>'}
                        </div>
                    </div>

                    <div class="token-overview">
                        <h2>Token Overview</h2>
                        <div class="token-grid">
                            <div class="token-detail">
                                <span class="label">Name</span>
                                <span class="value">${rugCheckData?.tokenMeta?.name || 'N/A'}</span>
                            </div>
                            <div class="token-detail">
                                <span class="label">Symbol</span>
                                <span class="value">${rugCheckData?.tokenMeta?.symbol || 'N/A'}</span>
                            </div>
                            <div class="token-detail">
                                <span class="label">Total Supply</span>
                                <span class="value">${rugCheckData?.token?.supply ? (rugCheckData.token.supply / Math.pow(10, rugCheckData.token.decimals)).toLocaleString() : 'N/A'}</span>
                            </div>
                            <div class="token-detail">
                                <span class="label">Decimals</span>
                                <span class="value">${rugCheckData?.token?.decimals || 'N/A'}</span>
                            </div>
                            <div class="token-detail">
                                <span class="label">LP Locked</span>
                                <span class="value">${rugCheckData?.markets?.[0]?.lp?.lpLockedPct || '0'}%</span>
                            </div>
                            <div class="token-detail">
                                <span class="label">Total Holders</span>
                                <span class="value">${rugCheckData?.totalHolders?.toLocaleString() || 'N/A'}</span>
                            </div>
                        </div>
                    </div>

                    <div class="markets">
                        <h2>Markets</h2>
                        <div class="markets-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Market</th>
                                        <th>Address</th>
                                        <th>Pair</th>
                                        <th>LP Mint</th>
                                        <th>Liquidity</th>
                                        <th>LP Locked</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${rugCheckData?.markets?.map(market => `
                                        <tr>
                                            <td>${market.name || 'Unknown'}</td>
                                            <td>${market.address ? `${market.address.substring(0, 6)}...${market.address.substring(market.address.length - 4)}` : 'N/A'}</td>
                                            <td>${market.pair || 'N/A'}</td>
                                            <td>${market.lpMint || 'N/A'}</td>
                                            <td>${formatVolumeData(market.liquidity) || 'N/A'}</td>
                                            <td>${market.lp?.lpLockedPct || '0'}%</td>
                                        </tr>
                                    `).join('') || '<tr><td colspan="6">No market data available</td></tr>'}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="top-holders">
                        <h2>Top Holders <span class="percentage">${rugCheckData?.topHolders ? 
                            (rugCheckData.topHolders.slice(0, 10).reduce((sum, holder) => sum + (holder.pct || 0), 0)).toFixed(2) + '%'
                            : '0%'}</span></h2>
                        <div class="holders-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Account</th>
                                        <th>Amount</th>
                                        <th>Percentage</th>
                                        <th>Type</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${rugCheckData?.topHolders?.map((holder, index) => {
                                        const isKnown = rugCheckData.knownAccounts?.[holder.owner];
                                        return `
                                            <tr>
                                                <td>
                                                    <a href="https://solscan.io/account/${holder.owner}" target="_blank">
                                                        ${holder.owner.substring(0, 6)}...${holder.owner.substring(holder.owner.length - 4)}
                                                    </a>
                                                    ${isKnown ? `<br><small>(${isKnown.name})</small>` : ''}
                                                </td>
                                                <td>${holder.uiAmount?.toLocaleString() || '0'}</td>
                                                <td>${holder.pct?.toFixed(2) || '0'}%</td>
                                                <td>${isKnown ? isKnown.type : '-'}</td>
                                            </tr>
                                        `;
                                    }).join('') || '<tr><td colspan="4">No holder data available</td></tr>'}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.innerHTML = html;
        }

        // Add event listener for token analysis
        document.getElementById('analyzeTokenBtn').addEventListener('click', () => {
            const address = document.getElementById('tokenAddress').value.trim();
            if (address) {
                analyzeToken(address);
            } else {
                showErrorNotification('Please enter a valid token address');
            }
        });
    </script>
</body>
</html>
